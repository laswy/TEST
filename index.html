<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>QU·∫¢N L√ù C√îNG VI·ªÜC</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <link rel="manifest" href="/manifest.json">
  
  <style>
    /* ========== iOS 26 Liquid Glass CSS ========== */
    * { 
        box-sizing: border-box; 
        transition: background-color 0.3s, color 0.3s, box-shadow 0.3s, transform 0.3s;
    }

    /* Thi·∫øt l·∫≠p n·ªÅn chung */
    body { 
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
      padding: 15px; 
      margin: 0;
      background-color: #e9ecef; /* N·ªÅn s√°ng */
      color: #1a1a1a;
    }
    body.dark-mode { 
      background-color: #121212; /* N·ªÅn t·ªëi */
      color: #f4f4f4; 
    }
    
    /* Liquid Glass Base - T·∫°o hi·ªáu ·ª©ng k√≠nh m·ªù n·ªïi */
    .glass-card {
        backdrop-filter: blur(25px);
        -webkit-backdrop-filter: blur(25px);
        background-color: rgba(255, 255, 255, 0.7); /* K√≠nh s√°ng, h∆°i trong */
        border: 1px solid rgba(255, 255, 255, 0.4);
        border-radius: 20px; /* G√≥c bo l·ªõn */
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
    }
    body.dark-mode .glass-card {
        background-color: rgba(45, 45, 45, 0.8); /* K√≠nh t·ªëi, h∆°i trong */
        border: 1px solid rgba(68, 68, 68, 0.5);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
    }

    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding: 0;
    }
    
    .title {
      font-size: 2em;
      font-weight: 700;
      flex-grow: 1;
      margin: 0;
      color: #007bff; /* M√†u ch·ªß ƒë·∫°o */
      text-align: left;
    }
    body.dark-mode .title {
        color: #ffc107;
    }

    /* Control Bar - Thay th·∫ø Nav Tabs c≈©, √°p d·ª•ng Liquid Glass */
    .control-bar {
        display: flex;
        background: transparent;
        margin-bottom: 20px;
        flex-wrap: wrap;
        gap: 10px;
    }

    /* Input Fields & Selects */
    input, select, textarea {
      width: 100%;
      padding: 15px;
      border: none; /* B·ªè border, d√πng shadow/glass effect */
      border-radius: 12px;
      font-size: 16px;
      background-color: rgba(255, 255, 255, 0.8);
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
      transition: all 0.2s;
      font-family: inherit;
    }
    
    input:focus, select:focus, textarea:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.3);
      background-color: #fff;
    }
    
    body.dark-mode input, body.dark-mode select, body.dark-mode textarea {
      background-color: rgba(51, 51, 51, 0.9);
      color: #f4f4f4;
      box-shadow: inset 0 1px 3px rgba(255, 255, 255, 0.1);
    }
    
    body.dark-mode input:focus, body.dark-mode select:focus, body.dark-mode textarea:focus {
      box-shadow: 0 0 0 3px rgba(255, 193, 7, 0.5);
    }

    /* Button Styling */
    .add-btn {
      width: 100%;
      padding: 15px;
      background: linear-gradient(135deg, #007bff, #0056b3); /* Blue Gradient */
      color: white;
      border: none;
      border-radius: 15px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 123, 255, 0.3);
    }
    
    .add-btn:hover {
      background: linear-gradient(135deg, #0056b3, #003d80);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 123, 255, 0.4);
    }

    /* Form and Input Layout */
    .form-container {
        padding: 20px;
        margin-bottom: 25px;
        /* √Åp d·ª•ng Liquid Glass cho Form */
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        background-color: rgba(255, 255, 255, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 20px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
    }
    body.dark-mode .form-container {
        background-color: rgba(45, 45, 45, 0.6);
        border: 1px solid rgba(68, 68, 68, 0.4);
    }
    
    .input-row {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
    }
    .input-row > * {
        flex: 1;
    }
    
    /* Task/Note list Item - √Åp d·ª•ng Liquid Glass */
    .item-list { 
      list-style: none; 
      padding: 0; 
      margin: 0;
    }
    
    .item {
      padding: 20px;
      margin-bottom: 15px;
      /* K·∫ø th·ª´a Liquid Glass */
      transition: all 0.3s;
      cursor: pointer;
      position: relative;
    }

    .item:hover {
        transform: translateY(-3px); /* Subtle lift */
        box-shadow: 0 10px 25px rgba(0,0,0,0.15);
    }
    
    .item-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 5px;
      line-height: 1.4;
    }

    .item-meta {
      font-size: 13px;
      color: #666;
      margin-top: 5px;
      padding-left: 5px; /* Th·ª•t l·ªÅ nh·∫π cho th√¥ng tin meta */
      border-left: 2px solid #ccc;
    }
    .item-meta strong {
        font-weight: 600;
        color: #333;
    }
    body.dark-mode .item-meta {
      color: #ccc;
      border-left: 2px solid #555;
    }
    body.dark-mode .item-meta strong {
        color: #fff;
    }
    
    .item.completed { opacity: 0.6; }
    .item.completed .item-title { text-decoration: line-through; }

    /* Tags */
    .tag {
      background: #007bff;
      color: white;
      padding: 4px 10px;
      border-radius: 15px;
      font-size: 12px;
      font-weight: 500;
      margin-right: 5px;
      margin-top: 5px;
      display: inline-block;
    }
    body.dark-mode .tag {
      background: #ffc107;
      color: #000;
    }

    /* Filter Buttons - N√∫t ƒëi·ªÅu khi·ªÉn Liquid Glass */
    .filter-buttons {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      padding: 10px;
      border-radius: 15px;
      /* Liquid Glass cho thanh filter */
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      background-color: rgba(255, 255, 255, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    }
    body.dark-mode .filter-buttons {
        background-color: rgba(45, 45, 45, 0.6);
        border: 1px solid rgba(68, 68, 68, 0.4);
    }
    
    .filter-buttons button {
      flex: 1;
      padding: 10px 15px;
      border: none;
      background: transparent;
      color: inherit;
      border-radius: 12px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
    }
    
    .filter-buttons button:hover,
    .filter-buttons button.active {
      background: rgba(0, 123, 255, 0.1);
      color: #007bff;
    }
    
    body.dark-mode .filter-buttons button:hover,
    body.dark-mode .filter-buttons button.active {
      background: rgba(255, 193, 7, 0.1);
      color: #ffc107;
    }

    /* Utility */
    .input-group { margin-bottom: 15px; }

    /* Mobile responsive */
    @media (max-width: 768px) {
      .input-row {
        flex-direction: column;
        gap: 10px;
      }
      .filter-buttons {
        gap: 5px;
      }
      .filter-buttons button {
        flex: none;
        width: calc(50% - 5px);
      }
    }
    /* Th√™m c√°c style kh√°c (Dark Mode Toggle, Search, Modal, Stats) */
    /* ... */

    .dark-mode-toggle {
        background: #007bff;
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 15px;
        cursor: pointer;
        font-size: 16px;
    }
    body.dark-mode .dark-mode-toggle {
        background: #ffc107;
        color: #000;
    }
    .btn-info {
        background: #17a2b8;
        color: white;
        border-radius: 10px;
    }
    .btn-warning {
        background: #ffc107;
        color: #000;
        border-radius: 10px;
    }
    .btn-danger {
        background: #dc3545;
        color: white;
        border-radius: 10px;
    }
    .item-actions {
        display: flex;
        gap: 8px;
        margin-top: 15px;
    }
    .item-actions button {
        flex: 1;
        padding: 8px 12px;
        border: none;
        cursor: pointer;
        font-size: 14px;
        border-radius: 10px;
    }
    
    /* Th√™m style cho n√∫t pin */
    .pin-icon {
        position: absolute;
        top: 15px;
        right: 15px;
        font-size: 20px;
        color: #ffc107;
        text-shadow: 0 0 5px rgba(0,0,0,0.2);
    }
    
    .item.pinned {
        border: 2px solid #ffc107;
        background-color: rgba(255, 255, 200, 0.7); /* N·ªÅn n·ªïi b·∫≠t h∆°n */
    }
    body.dark-mode .item.pinned {
        border: 2px solid #ffc107;
        background-color: rgba(61, 51, 0, 0.8);
    }
    .search-container {
        position: relative;
        margin-bottom: 20px;
    }
    .search-icon {
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 18px;
        color: #666;
    }
    .search-input {
        padding-right: 45px;
    }
    /* Modal styles */
    .modal {
        display: none;
        position: fixed;
        z-index: 100;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.4);
        padding-top: 60px;
    }
    .modal-content {
        background-color: #fefefe;
        margin: 5% auto;
        padding: 20px;
        border-radius: 20px;
        width: 90%;
        max-width: 500px;
    }
    .close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
    }
    .close:hover,
    .close:focus {
        color: #000;
        text-decoration: none;
        cursor: pointer;
    }
  </style>
</head>
<body>
  
  <div class="header">
    <h1 class="title">üìã Qu·∫£n L√Ω C√¥ng Vi·ªác</h1>
    <button class="dark-mode-toggle" onclick="toggleDarkMode()">‚òÄÔ∏è/üåô</button>
  </div>
  
  <div class="header-tools" style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px;">
    <button class="dark-mode-toggle" onclick="connectDataFile()">üîó K·∫øt n·ªëi t·ªáp</button>
    <button class="dark-mode-toggle" onclick="changeDataFile()">üìÇ Ch·ªçn t·ªáp</button>
    <button class="dark-mode-toggle" onclick="manualSave()">üíæ L∆∞u ngay</button>
    <button class="dark-mode-toggle" onclick="reloadFromFile()">‚Ü©Ô∏è T·∫£i l·∫°i</button>
    <span id="dataFileLabel" style="font-size:12px; opacity:0.8;"></span>
    <button class="dark-mode-toggle" onclick="exportData()">‚¨áÔ∏è Xu·∫•t</button>
    <input type="file" id="importFile" accept=".json" style="display: none;" onchange="handleImportFile(this, 'merge')">
    <button class="dark-mode-toggle" onclick="document.getElementById('importFile').click()">‚¨ÜÔ∏è Nh·∫≠p (H·ª£p nh·∫•t)</button>
  </div>
  
  <div id="tasksTab" class="tab-content active">
    
    <div class="form-container">
      <div class="input-group">
        <input type="text" id="taskInput" placeholder="N·ªôi dung c√¥ng vi·ªác">
      </div>
      
      <div class="input-row">
        <input type="datetime-local" id="receiveTime" placeholder="Th·ªùi gian nh·∫≠n c√¥ng vi·ªác">
        <input type="date" id="endTime" placeholder="H·∫°n ho√†n th√†nh">
        <select id="prioritySelect">
          <option value="low">ƒê·ªô ∆∞u ti√™n: Th·∫•p</option>
          <option value="medium" selected>ƒê·ªô ∆∞u ti√™n: Trung b√¨nh</option>
          <option value="high">ƒê·ªô ∆∞u ti√™n: Cao</option>
        </select>
      </div>
      
      <div class="input-row">
        <input type="text" id="assignedToInput" placeholder="üë§ Giao vi·ªác cho ai (ng∆∞·ªùi th·ª±c hi·ªán)">
        <input type="text" id="taskTags" placeholder="üè∑Ô∏è Th·∫ª (c√°ch nhau b·ªüi d·∫•u ph·∫©y)">
      </div>
      
      <button class="add-btn" onclick="addTask()">‚ûï TH√äM C√îNG VI·ªÜC</button>
    </div>

    <div class="search-container">
      <input type="text" class="search-input" id="taskSearch" placeholder="üîç T√¨m ki·∫øm c√¥ng vi·ªác..." onkeyup="searchTasks()">
      <span class="search-icon">üîç</span>
    </div>
    
    <div class="filter-buttons">
      <button class="active" onclick="setTaskFilter('all')">T·∫•t c·∫£</button>
      <button onclick="setTaskFilter('active')">Ch∆∞a ho√†n th√†nh</button>
      <button onclick="setTaskFilter('completed')">ƒê√£ ho√†n th√†nh</button>
      <button onclick="setTaskFilter('pinned')">ƒê√£ ghim</button>
    </div>
    
    <ul id="taskList" class="item-list">
      </ul>
    
    <div class="stats-container glass-card">
      <h3 style="margin-top:0;">üìä Th·ªëng k√™ C√¥ng vi·ªác</h3>
      <div class="stats-grid">
        <div class="stat-item">
          <div class="stat-number" id="totalTasks">0</div>
          <div class="stat-label">T·ªïng c·ªông</div>
        </div>
        <div class="stat-item">
          <div class="stat-number" id="completedTasks">0</div>
          <div class="stat-label">Ho√†n th√†nh</div>
        </div>
        <div class="stat-item">
          <div class="stat-number" id="activeTasks">0</div>
          <div class="stat-label">ƒêang ch·ªù</div>
        </div>
        <div class="stat-item">
          <div class="stat-number" id="pinnedTasks">0</div>
          <div class="stat-label">ƒê√£ ghim</div>
        </div>
      </div>
    </div>
    
  </div> <div id="editTaskModal" class="modal">
    <div class="modal-content glass-card">
      <span class="close" onclick="closeEditTaskModal()">&times;</span>
      <h2>‚úèÔ∏è S·ª≠a C√¥ng vi·ªác</h2>
      <div class="input-group">
        <input type="text" id="editTaskInput" placeholder="N·ªôi dung c√¥ng vi·ªác">
      </div>
      <div class="input-row">
        <input type="datetime-local" id="editReceiveTime">
        <input type="date" id="editEndTime">
        <select id="editPrioritySelect">
          <option value="low">Th·∫•p</option>
          <option value="medium">Trung b√¨nh</option>
          <option value="high">Cao</option>
        </select>
      </div>
      <div class="input-row">
        <input type="text" id="editAssignedToInput" placeholder="üë§ Giao vi·ªác cho ai (ng∆∞·ªùi th·ª±c hi·ªán)">
      </div>
      <div class="input-row">
        <input type="text" id="editTaskTags" placeholder="Th·∫ª (c√°ch nhau b·ªüi d·∫•u ph·∫©y)">
      </div>
      <div class="input-group">
        <label for="editHistory" style="font-weight: bold; margin-bottom: 5px; display: block;">L·ªãch s·ª≠ S·ª≠a/Chuy·ªÉn giao (Ch·ªâ c·∫≠p nh·∫≠t khi c√≥ thay ƒë·ªïi quan tr·ªçng):</label>
        <textarea id="editHistory" placeholder="L·ªãch s·ª≠ s·ª≠a ch·ªØa, chuy·ªÉn giao c√¥ng vi·ªác..."></textarea>
      </div>
      
      <button class="add-btn" onclick="saveEditTask()">üíæ L∆ØU THAY ƒê·ªîI</button>
    </div>
  </div>
  
  <div id="toast" class="toast"></div>

  <script>
    // === Bi·∫øn to√†n c·ª•c ===
    let tasks = [];
    let currentTaskFilter = 'all';
    let editingTaskId = null; // Bi·∫øn ƒë·ªÉ l∆∞u ID c·ªßa c√¥ng vi·ªác ƒëang ch·ªânh s·ª≠a

    // === Ti·ªán √≠ch ===
    function showToast(message, type = 'success') {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.className = `toast show ${type}`;
      setTimeout(() => {
        toast.classList.remove('show');
      }, 3000);
    }

    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');
      localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
    }
    
    function formatDateDisplay(datetimeString, includeTime = true) {
        if (!datetimeString) return 'N/A';
        try {
            const date = new Date(datetimeString);
            const dateStr = date.toLocaleDateString('vi-VN');
            if (!includeTime) return dateStr;
            // L·∫•y gi·ªù, ph√∫t v√† th√™m AM/PM
            const timeStr = date.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });
            return `${timeStr} ${dateStr}`;
        } catch {
            return datetimeString; // Tr·∫£ v·ªÅ nguy√™n b·∫£n n·∫øu kh√¥ng parse ƒë∆∞·ª£c
        }
    }

    // === L∆∞u/T·∫£i D·ªØ li·ªáu ===
    function loadData() {
      const stored = localStorage.getItem('todoAppData');
      if (stored) {
        const data = JSON.parse(stored);
        tasks = data.tasks || [];
      }
    }

    function saveData() {
      localStorage.setItem('todoAppData', JSON.stringify({ tasks, lastSaved: new Date().toISOString() }));
    }

    // === C√¥ng vi·ªác ===
    function addTask() {
      const text = document.getElementById('taskInput').value.trim();
      // ƒê√£ ƒë·ªïi th√†nh receiveTime (datetime-local)
      const receive = document.getElementById('receiveTime').value; 
      const end = document.getElementById('endTime').value;
      const priority = document.getElementById('prioritySelect').value;
      const tagsStr = document.getElementById('taskTags').value.trim();
      const assignedTo = document.getElementById('assignedToInput').value.trim(); 
      
      if (!text) return showToast('Vui l√≤ng nh·∫≠p n·ªôi dung c√¥ng vi·ªác!', 'error');

      const task = { 
        id: Date.now(), 
        text, 
        receiveTime: receive, // NEW: Th·ªùi gian nh·∫≠n
        endTime: end, 
        priority, 
        tags: tagsStr ? tagsStr.split(',').map(t => t.trim()).filter(t => t) : [], 
        completed: false, 
        completedTime: null, 
        pinned: false, 
        assignedTo, 
        editHistory: [], // NEW: L·ªãch s·ª≠ ch·ªânh s·ª≠a/chuy·ªÉn giao
        createdAt: new Date().toISOString() 
      };
      
      tasks.unshift(task); 
      saveData(); 
      renderTasks(); 
      updateTaskStats();

      // Clear form fields
      document.getElementById('taskInput').value = '';
      document.getElementById('receiveTime').value = '';
      document.getElementById('endTime').value = '';
      document.getElementById('prioritySelect').value = 'medium';
      document.getElementById('taskTags').value = '';
      document.getElementById('assignedToInput').value = ''; 
      showToast('ƒê√£ th√™m c√¥ng vi·ªác!');
    }

    function renderTasks() {
      const list = document.getElementById('taskList');
      list.innerHTML = '';
      
      let filtered = tasks.filter(task => {
        if (currentTaskFilter === 'active') return !task.completed;
        if (currentTaskFilter === 'completed') return task.completed;
        if (currentTaskFilter === 'pinned') return task.pinned;
        return true;
      });

      const search = document.getElementById('taskSearch')?.value.toLowerCase();
      if (search) {
        filtered = filtered.filter(t => 
          t.text.toLowerCase().includes(search) || 
          t.tags.some(tag => tag.toLowerCase().includes(search)) ||
          t.assignedTo?.toLowerCase().includes(search) 
        );
      }

      filtered.sort((a, b) => b.pinned - a.pinned || new Date(b.createdAt) - new Date(a.createdAt));

      if (filtered.length === 0) {
        list.innerHTML = '<p class="text-center item-meta">Kh√¥ng c√≥ c√¥ng vi·ªác n√†o.</p>';
        return;
      }

      for (const task of filtered) {
        const li = document.createElement('li');
        li.className = 'item task-item glass-card'; 
        if (task.completed) li.classList.add('completed');
        if (task.pinned) li.classList.add('pinned');

        const tagsHtml = task.tags.map(tag => `<span class="tag">${tag}</span>`).join('');
        const completedTimeHtml = task.completed && task.completedTime ? 
            `<div class="item-meta" style="color: #28a745; font-weight: bold;">‚úÖ Ho√†n th√†nh: ${formatDateDisplay(task.completedTime, true)}</div>` : '';
        
        // C·∫≠p nh·∫≠t c√°ch hi·ªÉn th·ªã th√¥ng tin
        const assignMeta = task.assignedTo ? `<div class="item-meta">üë§ **Giao cho**: ${task.assignedTo}</div>` : '';
        const receiveMeta = task.receiveTime ? 
            `<div class="item-meta">üïí **Th·ªùi gian nh·∫≠n**: ${formatDateDisplay(task.receiveTime)}</div>` : '';
        const deadlineMeta = task.endTime ? 
            `<div class="item-meta">üìÖ **H·∫°n ho√†n th√†nh**: ${formatDateDisplay(task.endTime, false)}</div>` : '';
        
        const historyHtml = (task.editHistory && task.editHistory.length > 0) ?
            `<div class="item-meta" style="margin-top: 10px;">üìú **L·ªãch s·ª≠ s·ª≠a/chuy·ªÉn giao**: <br/>` +
            task.editHistory.map(h => `<span style="display: block; margin-left: 10px; font-size: 12px; color: #888;">- ${h.time}: ${h.note}</span>`).join('') +
            `</div>` : '';


        li.innerHTML = `
          ${task.pinned ? '<div class="pin-icon">üìå</div>' : ''}
          <div class="item-title">${task.text}</div>
          ${tagsHtml ? `<div class="item-tags">${tagsHtml}</div>` : ''}
          
          ${receiveMeta}
          ${deadlineMeta}
          ${assignMeta}
          ${historyHtml}
          
          <div class="item-meta">
            <span>‚ú® ƒê·ªô ∆∞u ti√™n: ${task.priority.charAt(0).toUpperCase() + task.priority.slice(1)}</span>
            <span>| T·∫°o: ${formatDateDisplay(task.createdAt, false)}</span>
          </div>
          ${completedTimeHtml}
          
          <div class="item-actions">
            <button class="btn-info" onclick="event.stopPropagation(); openEditTaskModal(${task.id})">‚úèÔ∏è S·ª≠a</button>
            <button class="btn-warning" onclick="event.stopPropagation(); toggleTaskPin(${task.id})">${task.pinned ? 'üìå B·ªè ghim' : 'üìå Ghim'}</button>
            <button class="btn-danger" onclick="event.stopPropagation(); deleteTask(${task.id})">üóëÔ∏è X√≥a</button>
            <button class="btn-primary" style="background: ${task.completed ? '#dc3545' : '#28a745'};" 
                    onclick="event.stopPropagation(); toggleTaskComplete(${task.id})">
              ${task.completed ? '‚Ü©Ô∏è Ho√†n t√°c' : '‚úÖ Ho√†n th√†nh'}
            </button>
          </div>
        `;
        list.appendChild(li);
      }
    }

    function toggleTaskComplete(id) {
      const task = tasks.find(t => t.id === id);
      if (task) {
        task.completed = !task.completed;
        task.completedTime = task.completed ? new Date().toISOString() : null;
        task.pinned = false; 
        saveData();
        renderTasks();
        updateTaskStats();
        showToast(task.completed ? 'C√¥ng vi·ªác ƒë√£ ho√†n th√†nh!' : 'ƒê√£ ho√†n t√°c c√¥ng vi·ªác!');
      }
    }

    function deleteTask(id) {
      if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a c√¥ng vi·ªác n√†y kh√¥ng?')) {
        tasks = tasks.filter(t => t.id !== id);
        saveData();
        renderTasks();
        updateTaskStats();
        showToast('ƒê√£ x√≥a c√¥ng vi·ªác!');
      }
    }

    function setTaskFilter(filter) {
      currentTaskFilter = filter;
      document.querySelectorAll('#tasksTab .filter-buttons button').forEach(btn => {
        btn.classList.remove('active');
      });
      document.querySelector(`#tasksTab .filter-buttons button[onclick="setTaskFilter('${filter}')"]`).classList.add('active');
      renderTasks();
    }

    function searchTasks() {
      renderTasks();
    }
    
    function toggleTaskPin(id) {
      const task = tasks.find(t => t.id === id);
      if (task) {
        task.pinned = !task.pinned;
        saveData();
        renderTasks();
        updateTaskStats();
        showToast(task.pinned ? 'ƒê√£ ghim c√¥ng vi·ªác!' : 'ƒê√£ b·ªè ghim c√¥ng vi·ªác!');
      }
    }

    function updateTaskStats() {
      document.getElementById('totalTasks').textContent = tasks.length;
      document.getElementById('completedTasks').textContent = tasks.filter(t => t.completed).length;
      document.getElementById('activeTasks').textContent = tasks.filter(t => !t.completed).length;
      document.getElementById('pinnedTasks').textContent = tasks.filter(t => t.pinned).length;
    }

    // === Edit Task Modal Functions ===
    function openEditTaskModal(id) {
      editingTaskId = id;
      const task = tasks.find(t => t.id === id);
      if (task) {
        document.getElementById('editTaskInput').value = task.text;
        
        // X·ª≠ l√Ω datetime-local: lo·∫°i b·ªè ph·∫ßn Z (n·∫øu c√≥)
        const receiveTimeValue = task.receiveTime ? task.receiveTime.substring(0, 16) : '';
        document.getElementById('editReceiveTime').value = receiveTimeValue;
        
        document.getElementById('editEndTime').value = task.endTime;
        document.getElementById('editPrioritySelect').value = task.priority;
        document.getElementById('editTaskTags').value = task.tags.join(', ');
        document.getElementById('editAssignedToInput').value = task.assignedTo || ''; 
        
        // NEW: Load l·ªãch s·ª≠ v√† hi·ªÉn th·ªã
        let historyText = '';
        if (task.editHistory && task.editHistory.length > 0) {
            historyText = task.editHistory.map(h => `${h.time}: ${h.note}`).join('\n');
        }
        document.getElementById('editHistory').value = historyText; 
        
        document.getElementById('editTaskModal').style.display = 'block';
      }
    }

    function closeEditTaskModal() {
      document.getElementById('editTaskModal').style.display = 'none';
      editingTaskId = null;
    }

    function saveEditTask() {
      const task = tasks.find(t => t.id === editingTaskId);
      if (task) {
        const oldAssignedTo = task.assignedTo;
        const newAssignedTo = document.getElementById('editAssignedToInput').value.trim();
        const historyNote = document.getElementById('editHistory').value.trim();
        const newReceiveTime = document.getElementById('editReceiveTime').value;

        // C·∫≠p nh·∫≠t c√°c tr∆∞·ªùng
        task.text = document.getElementById('editTaskInput').value.trim();
        task.receiveTime = newReceiveTime;
        task.endTime = document.getElementById('editEndTime').value;
        task.priority = document.getElementById('editPrioritySelect').value;
        task.tags = document.getElementById('editTaskTags').value.trim().split(',').map(t => t.trim()).filter(t => t);
        task.assignedTo = newAssignedTo; 

        // X·ª≠ l√Ω l·ªãch s·ª≠: Th√™m ghi ch√∫ m·ªõi (n·∫øu c√≥) V√Ä thay ƒë·ªïi ng∆∞·ªùi giao vi·ªác
        const newHistory = [];
        if (historyNote) {
            // Parse l·ªãch s·ª≠ c≈©
            const lines = historyNote.split('\n').filter(line => line.trim() !== '');
            for (const line of lines) {
                const parts = line.split(':');
                if (parts.length >= 2) {
                    newHistory.push({
                        time: parts[0].trim(),
                        note: parts.slice(1).join(':').trim()
                    });
                }
            }
        }

        // T·ª± ƒë·ªông th√™m l·ªãch s·ª≠ khi ng∆∞·ªùi giao vi·ªác thay ƒë·ªïi
        if (oldAssignedTo !== newAssignedTo) {
            const timeStr = new Date().toLocaleTimeString('vi-VN') + ' ' + new Date().toLocaleDateString('vi-VN');
            const note = `Chuy·ªÉn giao t·ª´ **${oldAssignedTo || 'N/A'}** sang **${newAssignedTo || 'N/A'}**`;
            // Th√™m v√†o ƒë·∫ßu ƒë·ªÉ hi·ªÉn th·ªã l·ªãch s·ª≠ g·∫ßn nh·∫•t tr∆∞·ªõc
            newHistory.unshift({ time: timeStr, note: note }); 
        }

        task.editHistory = newHistory; 
        
        saveData();
        renderTasks();
        updateTaskStats();
        showToast('ƒê√£ c·∫≠p nh·∫≠t c√¥ng vi·ªác!');
        closeEditTaskModal();
      }
    }

    // === Kh·ªüi t·∫°o & S·ª± ki·ªán ===
    window.onload = function() {
      loadData();
      renderTasks();
      updateTaskStats();
      
      // Kh√¥i ph·ª•c Dark Mode
      if (localStorage.getItem('darkMode') === 'true') {
        document.body.classList.add('dark-mode');
      }

      // Kh√¥i ph·ª•c filter (l√∫c kh·ªüi t·∫°o ch·ªâ c·∫ßn set active cho n√∫t "T·∫•t c·∫£")
      document.querySelector(`#tasksTab .filter-buttons button[onclick="setTaskFilter('all')"]`).classList.add('active');
    };
    
    // ƒê√≥ng Modal khi click ra ngo√†i
    window.onclick = function(event) {
      if (event.target == document.getElementById('editTaskModal')) {
        closeEditTaskModal();
      }
    }

    // ========== JS Qu·∫£n l√Ω T·ªáp tin (Gi·ªØ l·∫°i logic c≈©) ==========
    let dataFileHandle = null;
    let savingQueued = false;
    
    // Gi·∫£ l·∫≠p h√†m idbGet v√† idbSet cho ƒë∆°n gi·∫£n
    async function idbGet(key) {
        // Trong m√¥i tr∆∞·ªùng th·ª±c t·∫ø, ƒë√¢y s·∫Ω l√† logic IndexedDB
        const stored = localStorage.getItem('idb:' + key);
        return stored ? JSON.parse(stored) : null;
    }
    async function idbSet(key, value) {
        // Trong m√¥i tr∆∞·ªùng th·ª±c t·∫ø, ƒë√¢y s·∫Ω l√† logic IndexedDB
        localStorage.setItem('idb:' + key, JSON.stringify(value));
    }
    
    function showFileLabel(name) {
      document.getElementById('dataFileLabel').textContent = `T·ªáp hi·ªán t·∫°i: ${name}`;
    }

    async function resolveHandleName(handle) {
      try {
        return handle.name;
      } catch {
        return 'T·ªáp kh√¥ng x√°c ƒë·ªãnh';
      }
    }

    async function requestWritePermission(handle) {
      const opts = { mode: 'readwrite' };
      try {
        const st = await handle.queryPermission(opts);
        if (st === 'granted') return true;
        const st2 = await handle.requestPermission(opts);
        return st2 === 'granted';
      } catch {
        return false;
      }
    }

    async function saveAllToFile() {
      if (!dataFileHandle) return;
      if (!(await requestWritePermission(dataFileHandle))) {
        showToast('Kh√¥ng c√≥ quy·ªÅn ghi v√†o t·ªáp!', 'error');
        return;
      }
      try {
        const writable = await dataFileHandle.createWritable();
        const data = { 
            tasks: window.tasks, 
            lastSaved: new Date().toISOString() 
        };
        await writable.write(JSON.stringify(data, null, 2));
        await writable.close();
        showToast('ƒê√£ l∆∞u v√†o t·ªáp!');
      } catch (e) {
        console.error('L·ªói khi ghi t·ªáp:', e);
        showToast('L·ªói l∆∞u t·ªáp: ' + e.message, 'error');
      }
    }

    async function loadFromCurrentFile() {
      if (!dataFileHandle) return;
      try {
        const file = await dataFileHandle.getFile();
        const text = await file.text();
        importDataText(text, 'overwrite');
        showToast('ƒê√£ t·∫£i l·∫°i d·ªØ li·ªáu t·ª´ t·ªáp.');
      } catch (e) {
        console.error('L·ªói khi ƒë·ªçc t·ªáp:', e);
        showToast('L·ªói ƒë·ªçc t·ªáp: ' + e.message, 'error');
      }
    }

    async function manualSave() {
        await saveAllToFile();
    }
    
    async function reloadFromFile() {
        await loadFromCurrentFile();
    }

    function exportData() {
      try {
        const stored = localStorage.getItem('todoAppData');
        const obj = stored ? JSON.parse(stored) : { tasks: window.tasks, lastSaved: new Date().toISOString() };
        const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const now = new Date();
        const ts = now.toISOString().replace(/[:.]/g, '-');
        a.href = url;
        a.download = `congviec-backup-${ts}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast('ƒê√£ xu·∫•t d·ªØ li·ªáu ra file JSON!');
      } catch (e) {
        console.error(e);
        showToast('Xu·∫•t d·ªØ li·ªáu th·∫•t b·∫°i!', 'error');
      }
    }

    function handleImportFile(input, mode) {
      const file = input.files && input.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          const text = evt.target.result;
          importDataText(text, mode);
        } catch (e) {
          console.error(e);
          showToast('Kh√¥ng th·ªÉ ƒë·ªçc file!', 'error');
        } finally {
          input.value = ''; // Reset input
        }
      };
      reader.readAsText(file);
    }

    function importDataText(text, mode) {
      try {
        const incomingData = JSON.parse(text);
        const incomingTasks = incomingData.tasks || [];

        if (mode === 'overwrite') {
            tasks = incomingTasks;
        } else if (mode === 'merge') {
            const taskMap = new Map(tasks.map(t => [t.id, t]));
            for (const t of incomingTasks) {
                // Merge logic: ∆∞u ti√™n b·∫£n ghi c√≥ createdAt m·ªõi h∆°n
                const existingTask = taskMap.get(t.id);
                if (existingTask) {
                    const curDate = new Date(existingTask.createdAt || 0);
                    const incDate = new Date(t.createdAt || 0);
                    if (incDate > curDate) taskMap.set(t.id, t);
                } else {
                    taskMap.set(t.id, t);
                }
            }
            tasks = Array.from(taskMap.values());
        }

        // S·∫Øp x·∫øp l·∫°i
        tasks.sort((a,b) => new Date(b.createdAt) - new Date(a.createdAt));
        
        saveData();
        renderTasks();
        updateTaskStats();
        showToast('ƒê√£ nh·∫≠p d·ªØ li·ªáu th√†nh c√¥ng!');

      } catch (e) {
        console.error('Invalid JSON in file', e);
        showToast('N·ªôi dung t·ªáp kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng.', 'error');
      }
    }

    // H√†m k·∫øt n·ªëi t·ªáp tin (s·ª≠ d·ª•ng File System Access API) - C√≥ th·ªÉ kh√¥ng ho·∫°t ƒë·ªông tr√™n m·ªçi tr√¨nh duy·ªát
    async function connectDataFile() {
      try {
        const handle = await window.showSaveFilePicker({ 
          suggestedName: 'congviec.json', 
          types: [{ description: 'JSON', accept: { 'application/json': ['.json'] } }] 
        });
        if (!(await requestWritePermission(handle))) {
          showToast('Ch∆∞a c√≥ quy·ªÅn ghi v√†o t·ªáp ƒë√£ ch·ªçn.', 'error'); 
          return;
        }
        dataFileHandle = handle;
        await idbSet('dataFileHandle', handle);
        await saveAllToFile();
        showFileLabel(await resolveHandleName(handle));
        showToast('ƒê√£ k·∫øt n·ªëi & l∆∞u d·ªØ li·ªáu v√†o t·ªáp.');
      } catch (e) { console.error(e); }
    } 

    async function changeDataFile() {
      try {
        const [handle] = await window.showOpenFilePicker({ 
          multiple: false, 
          types: [{ description: 'JSON', accept: { 'application/json': ['.json'] } }] 
        });
        if (!(await requestWritePermission(handle))) {
          showToast('Ch∆∞a c√≥ quy·ªÅn ghi v√†o t·ªáp ƒë√£ ch·ªçn.', 'error');
          return;
        }
        dataFileHandle = handle;
        await idbSet('dataFileHandle', handle);
        showFileLabel(await resolveHandleName(handle));
        await loadFromCurrentFile(); // T·∫£i d·ªØ li·ªáu t·ª´ t·ªáp m·ªõi
      } catch (e) { console.error(e); }
    }

    // Auto-save logic (gi·ªØ l·∫°i)
    (function interceptLocalStorage() {
      const orig = Storage.prototype.setItem;
      Storage.prototype.setItem = function(key, value) {
        const result = orig.apply(this, arguments);
        if (key === 'todoAppData') {
          if (!savingQueued) {
            savingQueued = true;
            setTimeout(async () => {
              try { await saveAllToFile(); } finally { savingQueued = false; }
            }, 700);
          }
        }
        return result;
      };
    })();

    window.addEventListener('DOMContentLoaded', async () => {
      try {
        const handle = await idbGet('dataFileHandle');
        if (handle) {
          dataFileHandle = handle;
          showFileLabel(await resolveHandleName(handle));
          await requestWritePermission(handle);
          await loadFromCurrentFile();
        } else {
          showFileLabel('Ch∆∞a k·∫øt n·ªëi t·ªáp.');
        }
      } catch (e) {
        console.error('Error loading file handle', e);
        showFileLabel('L·ªói t·∫£i t·ªáp tin.');
      }
    });
  </script>
</body>
</html>
